비전공자를 위한 컴퓨터공학
==============

- L2: 근거리에서 누구에게 보낼 것인가?
- L3: internet protocol
- L4: TCP는 복잡, UDP는 L3를 거의 그대로 사용
- GET, POST의 차이? body를 어디에 담느냐

# 쿠키(cookie)
- 헤더에 있는 데이터
- 사용할 수 있는 방법: '나는 이미 로그인을 하고 있어.'
- 편리함

# 세션
- 의사선생님한테 진료를 받는 것 = 세션
- 끝났다는게 불확실함
- 홍길동이 한번 네이버에 로그인 함 -> 다시 또 올지 안올지는 불분명함 but 지속적임
- 로그아웃하면 명시적으로 세션 완료
- 서버는 생성한 세션에 대한 만료시간이 있음
- context data는 모두 세션에 저장되어 있음

- 기본적으로 backend는 stateless로 구현한다. (= pure function) = 동일한 input에는 동일한 output
- 순수함수가 아닌 경우: context가 함수 외부의 것을 의존할 때
- stateless가 중요한 이유는 분산처리를 하기 때문이다. 분산처리시에는 context 정보를 저장하는 메모리DB를 따로 만든다.
- context, stateless, pure function, 
- 보통 context 저장할 때 redis를 사용 - redis는 ram에 key-value 형식으로 데이터 저장
- 유효기간을 지정할 수 있음(== session)
- memcached를 예전에는 사용했음

# 백앤드 기초
## 프로세스(= 인스턴스)
- 네트워크 레벨에서는 4,7와 관련
- 4에서 포트 번호를 보고 운영체제가 전달 결정
- 프로세스에도 ID가 있음 = PID
- 운영체제에서 가장 중요한 것은 어플리케이션 관리
- 프로세스는 많은 것을 추상화함 > 
- 운영체제에서는 가상메모리를 제공(쓰던 안쓰던 4GB를 제공). 메모리를 공유하게 되는데 가상메모리는 '공유'하고 있는 느낌을 주지 않음.
- 운영체제에서 키보드, 마우스 등 하드웨어 사용도 제공 및 관리
	+ stack: local memory(지역변수)와 관련
	+ heap: 새로운 클래스 생성시 사용
	+ data, text: 
- 함수 실행시 지역변수를 확인해서 stack에 미리 데이터를 할당해 놓음 - 자주 생겼다가 사라짐
- stack은 push, pop으로 일함
- stack 구조상 한 방향으로 쌓고 한 방향으로 나감 -> 가변적. 
- heap, stack은 언제든지 크기가 변경될 수 있다. 

- script 언어: 컴파일 개념이 없음 - 코드가 인터프리터에 들어가면 그때그때 정해진 동작을 하게 됨 -> 가상 메모리 환경의 실제 환경을 보기가 어려움
- native 언어: 컴파일했을때 컴퓨터 언어(기계어)로 변경
- java는 컴파일하면 중립기계어로 추출 - runtime에 기계어로 변환

- 코드는 변하지 않음. static, global -> 컴파일 될때 결정됨

- 함수를 호출한다 = 그 위치로 점프한다.
- library: 많이 쓰는 코드를 모아둠.
- static library: 코드를 그대로 복사해서 박아둠 -> 실행파일 코드 크기가 커짐, 호환성 좋음
- dynamic library: 주소값만 가지고 있음 -> 호환성 안좋음(dll없음), 해킹 쉬움
- 지금 script 언어는 동적 라이브러리 형식으로 패키지 매니저가 관리. 실행되는 방법은 static 처럼 됨

- 쓰레드 하나마다 CPU가 붙는 것...?
- 웹서버와 쓰레드가 잘 맞음. 웹서버는 stateless 하니까. 

- 예전 아파치에서는 쓰레드의 개념이 없어서 프로세스를 여러개 띄웠음
- 프로세스를 옮길 때마다 context swiching을 하게 됨. - 비효율

## Web Server vs App Server
- uri: resource -> 어떤 쓰레드에 던질 것인지를 처리할 수 있음
- resource는 thread로 볼 수 있음
- web server: apache, nginx
- app server: 사람들이 짠 코드????
- 아파치, 엔진엑스로 로드밸런서를 구현할 수 있다. 단, AWS는 로드밸런서가 별도임

## serverside rendering vs clientside rendering
- 랜더링?: 웹이 어떻게 생겼는지 결정하는 건 html, css, javascript (frontend)
- dom: 도큐먼트 
- dom을 서버에서 만들어서 html페이지를 내려줄수도 있고 프론트에서 계산해서 내려줄 수도 있음
- 서버사이드 랜더링은 서버의 부하가 커진다는 단점, 검색엔진에서는 장점이 됨. 검색을 하면 서버에 request를 요청함. 서버에서 계산하면 완성되서 전달됨. 클라이언트에서 계산하면 
- 서버사이드에서 계산을 하면 html에는 링크가 채워져서 오고, 클라이언트 차이점과 장단점

- 장고는 동적 컨텐츠를 처리하는데 특화되어 있음
- 아파치나 엔진엑스는 정적 컨텐츠를 처리하는게 좋음 
- seo는 서버사이드 랜더링이 따라옴

- was: 톰캣, 장고, 사람들이 짠 프로그래밍이 와스
- 서버에 코드를 올릴 떄 올리는 인터페이스를 CGI

- node는 아파치랑 연동하지 않아도 풀 스피드 나옴. 
- 장고도 아파치 안띄워도 실행이 됨. 띄우는 이유는 한꺼번에 여러 쓰레드로 처리

- node가 one thread 라서 생기는 장점 -> context 스위칭이 없어서 더 빠름
- 단점은 응답이 갔다가 돌아오기 까지 기다려야함 -> response가 오래 걸리는 작업이 있다면 이걸 사용하면 안됌
- stdout: 어플리케이션을 모듈로 생각했을때 stdin, stdout이 있음
- 추상화의 장점?: 형식만 맞으면 어떤 장비든 input이 될 수 있음. 서버에서는 stdout을 콘솔로 지정함. output을 CGI는 작성한 코드의 output이 CGI의 인풋이 되도록 할 수 있다. 파이프로 구성되어서 연결할 수 있음. 







